#!/usr/bin/php
<?php
require_once 'beercrush/oak.class.php';

declare(ticks = 1);


$keep_running=true;

if ($argc<2)
{
	print "Usage: ".$argv[0]." <conf file>\n";
	exit;
}

$oak=new OAK($argv[1]);
$oak->log_ident('update_doc');

$pid_file='/var/run/BeerCrush/'.basename($argv[0]).'.pid';

// Don't run this more than once at a time
if (file_exists($pid_file))
{
	// Refuse to run again
	$pid=file_get_contents($pid_file);
	$oak->log("Another process is currently running (PID=$pid). Refusing to run a 2nd instance.");
	exit;
}

$pid=pcntl_fork();
if ($pid==-1)
{
	print "Unable to daemonize\n";
}
else if ($pid)
{
	file_put_contents($pid_file,$pid);
}
else
{
	$oak->log('started pid='.getmypid());

	pcntl_signal(SIGUSR1,"sig_handler");
	pcntl_signal(SIGUSR2,"sig_handler");
	pcntl_signal(SIGHUP,"sig_handler");
	pcntl_signal(SIGTERM,"sig_handler");
	pcntl_signal(SIGINT,"sig_handler");
	pcntl_signal(SIGABRT,"sig_handler");
	pcntl_signal(SIGCONT,"sig_handler");

	while ($keep_running)
	{
		$msg=$oak->get_queue_msg('updates');
		if ($msg===false)
		{
			sleep(15);
		}
		else
		{
			// Determine the doc type and call the appropriate script
			$parts=split(':',$msg);
			
			// TODO: fix in the db so that beer docs have an ID that starts with 'beer:'
			if (count($parts)==2)  // Beers don't have a doc type in their ID (stupid!)...
			{	// ...so we pretend it does.
				array_unshift($parts,'beer');
			}

			// Find the script for this onchange
			$prog=$oak->config_bin_dir().'/onchange/'.$parts[0];
	
			if (!is_executable($prog))
			{
				// Silently ignore this
			}
			else
			{
				$oak->log('Queue msg: "'.$msg.'" Running '.escapeshellcmd($prog).' '.escapeshellarg($msg));
				
				$r=exec(escapeshellcmd($prog).' '.escapeshellarg($msg),$output,$return_var);
	
				foreach ($output as $line)
				{
					$oak->log("$msg $line");
				}
			}
		}
	}

	$oak->log("Shutting down.");
	// Remove the PID file
	if (file_exists($pid_file) && unlink($pid_file)===FALSE)
		$oak->log("failed to unlink $pid_file");

}

function sig_handler($signo)
{
	global $oak;
	$oak->log("Received signal $signo");

	global $keep_running;
	
	switch ($signo)
	{
	case SIGTERM: // 15
	case SIGINT:  // 2
	case SIGQUIT: // 3       /* Quit (POSIX).  */
	case SIGABRT: // 6       /* Abort (ANSI).  */
	case SIGKILL: // 9       /* Kill, unblockable (POSIX).  */
	case SIGHUP:  // 1
	case SIGSTOP: // 19      /* Stop, unblockable (POSIX).  */
	case SIGTSTP: // 20      /* Keyboard stop (POSIX).  */
		$keep_running=false;
		break;
	case SIGUSR1: // 10      /* User-defined signal 1 (POSIX).  */
	case SIGUSR2: // 12      /* User-defined signal 2 (POSIX).  */
	case SIGCONT: // 18      /* Continue (POSIX).  */
		break;
	default:
		break;
	}
}



?>